{
    "sourceFile": "src/Utils.cpp",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1628034601404,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1628034601403,
            "name": "Commit-0",
            "content": "/**\n * S3 Storage Plugin - A plugin for Orthanc DICOM Server for storing\n * DICOM data in Amazon Simple Storage Service (AWS S3).\n *\n * Copyright (C) 2018 (Radpoint Sp. z o.o., Poland)\n * Marek Kwasecki, Bartłomiej Pyciński\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see <https://www.gnu.org/licenses/>.\n **/\n\n#include \"Utils.hpp\"\n#include \"OrthancException.h\"\n\n#include <boost/filesystem.hpp>\n#include <boost/filesystem/fstream.hpp>\n#include <boost/date_time/posix_time/posix_time.hpp>\n\n#include <string>\n\nnamespace OrthancPlugins {\nnamespace Utils {\n\nvoid readFile(void** content,\n              int64_t *size,\n              const std::string& path) {\n\n    if (!isRegularFile(path))\n    {\n        std::string s(\"The path does not point to a regular file: \");\n        s += path;\n        OrthancPluginLogError(context, s.c_str());\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_RegularFileExpected);\n    }\n\n    boost::filesystem::ifstream f;\n    f.open(path, std::ifstream::in | std::ifstream::binary);\n    if (!f.good())\n    {\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_InexistentFile);\n    }\n\n    *size = GetStreamSize(f);\n    if (*size != 0)\n    {\n        //it so happen that memory free'd is by\n        //context->Free which in turn is ::free\n        *content = malloc(*size);\n        if (*content != nullptr) {\n            f.read(static_cast<char*>(*content), *size);\n        }\n    }\n\n    f.close();\n}\n\nvoid writeFile(const void* content,\n               int64_t size,\n               const std::string& path) {\n\n    boost::filesystem::path boostpath (path);\n\n    if (boost::filesystem::exists(boostpath))\n    {\n      // Extremely unlikely case: This Uuid has already been created\n      // in the past.\n      //TODO handle this case\n      throw Orthanc::OrthancException(Orthanc::ErrorCode_InternalError);\n    }\n\n    if (boost::filesystem::exists(boostpath.parent_path()))\n    {\n      if (!boost::filesystem::is_directory(boostpath.parent_path()))\n      {\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_DirectoryOverFile);\n      }\n    }\n    else\n    {\n      if (!boost::filesystem::create_directories(boostpath.parent_path()))\n      {\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_FileStorageCannotWrite);\n      }\n    }\n\n\n    boost::filesystem::ofstream f;\n    f.open(path, std::ofstream::out | std::ofstream::binary);\n    if (!f.good())\n    {\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_CannotWriteFile);\n    }\n\n    if (size != 0)\n    {\n        f.write(reinterpret_cast<const char*>(content), size);\n\n        if (!f.good())\n        {\n            f.close();\n            throw Orthanc::OrthancException(Orthanc::ErrorCode_FileStorageCannotWrite);\n        }\n    }\n\n    f.close();\n}\n\nvoid writeFile(const std::string& content,\n               const std::string& path) {\n    writeFile(!content.empty() ? content.c_str() : nullptr, content.size(), path);\n}\n\nvoid removeFile(const std::string& path) {\n    if (boost::filesystem::exists(path))\n    {\n        if (isRegularFile(path))\n        {\n            boost::filesystem::remove(path);\n        }\n        else\n        {\n            throw Orthanc::OrthancException(Orthanc::ErrorCode_RegularFileExpected);\n        }\n\n        // Remove the two parent directories, ignoring the error code if\n        // these directories are not empty\n        try {\n            boost::filesystem::remove(boost::filesystem::path(path).parent_path());\n            boost::filesystem::remove(boost::filesystem::path(path).parent_path().parent_path());\n        }\n        catch (...)\n        {\n          // Ignore the error\n        }\n    }\n}\n\nuint64_t getFileSize(const std::string& path) {\n    try\n    {\n        return static_cast<uint64_t>(boost::filesystem::file_size(path));\n    }\n    catch (boost::filesystem::filesystem_error&)\n    {\n        throw Orthanc::OrthancException(Orthanc::ErrorCode_InexistentFile);\n    }\n}\n\nvoid makeDirectory(const std::string& path) {\n    if (boost::filesystem::exists(path))\n    {\n        if (!boost::filesystem::is_directory(path))\n        {\n            throw Orthanc::OrthancException(Orthanc::ErrorCode_DirectoryOverFile);\n        }\n    }\n    else\n    {\n        if (!boost::filesystem::create_directories(path))\n        {\n            throw Orthanc::OrthancException(Orthanc::ErrorCode_MakeDirectory);\n        }\n    }\n}\n\nint64_t GetStreamSize(std::istream& f) {\n    // http://www.cplusplus.com/reference/iostream/istream/tellg/\n    f.seekg(0, std::ios::end);\n    int64_t size = f.tellg();\n    f.seekg(0, std::ios::beg);\n\n    return size;\n}\n\nbool isRegularFile(const std::string& path) {\n    namespace fs = boost::filesystem;\n\n    try\n    {\n        if (fs::exists(path))\n        {\n            fs::file_status status = fs::status(path);\n            return (status.type() == boost::filesystem::regular_file ||\n                    status.type() == boost::filesystem::reparse_file);   // Fix BitBucket issue #11\n        }\n    }\n    catch (fs::filesystem_error&)\n    {\n    }\n\n    return false;\n}\n\nbool isExistingFile(const std::string& path) {\n    return boost::filesystem::exists(path);\n}\n\nbool isDirectory(const std::string& path) {\n    return boost::filesystem::is_directory(path);\n\n}\n\n}\n}\n"
        }
    ]
}